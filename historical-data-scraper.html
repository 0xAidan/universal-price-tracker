<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Historical Data Scraper - Universal Price Tracker</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #0f0f1e 0%, #1a1a2e 100%);
            color: #fff;
            min-height: 100vh;
            padding: 20px;
            line-height: 1.6;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 40px;
        }

        h1 {
            font-size: clamp(2rem, 5vw, 3rem);
            font-weight: 700;
            background: linear-gradient(90deg, #00d4ff, #00ff88);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
        }

        .subtitle {
            font-size: 1.2rem;
            color: #888;
            margin-bottom: 20px;
        }

        .data-sources {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
            margin-bottom: 40px;
        }

        .source-card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 25px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .source-title {
            font-size: 1.3rem;
            color: #00d4ff;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .source-description {
            color: #ccc;
            margin-bottom: 15px;
            line-height: 1.5;
        }

        .source-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }

        .source-stat {
            padding: 8px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 5px;
            text-align: center;
            font-size: 0.85rem;
        }

        .scrape-btn {
            width: 100%;
            padding: 10px;
            border: none;
            border-radius: 6px;
            background: linear-gradient(45deg, #00d4ff, #00ff88);
            color: #000;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .scrape-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 212, 255, 0.3);
        }

        .scrape-btn:disabled {
            background: #444;
            color: #888;
            cursor: not-allowed;
            transform: none;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            margin-bottom: 30px;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            background: linear-gradient(45deg, #00d4ff, #00ff88);
            color: #000;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0, 212, 255, 0.3);
        }

        .btn.secondary {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .progress-section {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 30px;
        }

        .progress-title {
            color: #00ff88;
            margin-bottom: 15px;
            font-weight: bold;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            margin: 10px 0;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00d4ff, #00ff88);
            border-radius: 4px;
            transition: width 0.3s ease;
            width: 0%;
        }

        .log-container {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 20px;
            max-height: 400px;
            overflow-y: auto;
        }

        .log-title {
            color: #00ff88;
            margin-bottom: 15px;
            font-weight: bold;
        }

        .log-entry {
            font-family: monospace;
            font-size: 0.85rem;
            padding: 5px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            color: #ccc;
        }

        .log-entry.success {
            color: #00ff88;
        }

        .log-entry.warning {
            color: #ffaa00;
        }

        .log-entry.error {
            color: #ff4444;
        }

        .log-entry.info {
            color: #00d4ff;
        }

        .status-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-indicator.active {
            background: #00ff88;
            animation: pulse 2s ease-in-out infinite;
        }

        .status-indicator.error {
            background: #ff4444;
        }

        .status-indicator.idle {
            background: #666;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        .data-preview {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            max-height: 200px;
            overflow-y: auto;
        }

        .data-preview-title {
            color: #00d4ff;
            font-size: 0.9rem;
            margin-bottom: 10px;
        }

        .data-preview-content {
            font-family: monospace;
            font-size: 0.8rem;
            color: #ccc;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Historical Data Scraper</h1>
            <p class="subtitle">Collect Real Market Data for Your Price Tracker</p>
        </header>

        <div class="data-sources" id="dataSources">
            <!-- Data sources will be populated by JavaScript -->
        </div>

        <div class="controls">
            <button class="btn" onclick="scrapeAllSources()">üîÑ Scrape All Sources</button>
            <button class="btn secondary" onclick="exportScrapedData()">üì• Export Data</button>
            <button class="btn secondary" onclick="clearScrapedData()">üóëÔ∏è Clear Data</button>
            <button class="btn secondary" onclick="viewDataSummary()">üìä View Summary</button>
        </div>

        <div class="progress-section">
            <div class="progress-title">Scraping Progress</div>
            <div class="progress-bar">
                <div class="progress-fill" id="overallProgress"></div>
            </div>
            <div id="progressText">Ready to scrape historical data</div>
        </div>

        <div class="log-container">
            <div class="log-title">Scraping Log</div>
            <div id="scrapingLog">
                <div class="log-entry">Historical data scraper initialized. Ready to collect market data.</div>
            </div>
        </div>
    </div>

    <script>
        // Historical Data Scraper System
        class HistoricalDataScraper {
            constructor() {
                this.dataSources = {
                    coingecko: {
                        name: 'CoinGecko API',
                        description: 'Cryptocurrency historical prices (Bitcoin, Ethereum, etc.)',
                        icon: 'ü™ô',
                        status: 'idle',
                        baseUrl: 'https://api.coingecko.com/api/v3',
                        rateLimit: 50, // requests per minute
                        assets: ['bitcoin', 'ethereum', 'solana', 'dogecoin'],
                        lastScrape: null,
                        dataPoints: 0
                    },
                    alphavantage: {
                        name: 'Alpha Vantage',
                        description: 'Stock market data (S&P 500, NASDAQ, individual stocks)',
                        icon: 'üìà',
                        status: 'idle',
                        baseUrl: 'https://www.alphavantage.co/query',
                        rateLimit: 5, // requests per minute (free tier)
                        assets: ['SPY', 'QQQ', 'DIA', 'AAPL', 'MSFT'],
                        lastScrape: null,
                        dataPoints: 0,
                        apiKey: 'demo' // User would need to get their own key
                    },
                    metalspriceapi: {
                        name: 'Metals Price API',
                        description: 'Precious metals historical data (Gold, Silver, Platinum)',
                        icon: 'ü•á',
                        status: 'idle',
                        baseUrl: 'https://api.metalspriceapi.com/v1',
                        rateLimit: 100, // requests per month on free tier
                        assets: ['GOLD', 'SILVER', 'PLATINUM', 'PALLADIUM'],
                        lastScrape: null,
                        dataPoints: 0
                    },
                    freeapi: {
                        name: 'Free Market Data',
                        description: 'Various free APIs aggregated for consumer goods, real estate',
                        icon: 'üè†',
                        status: 'idle',
                        baseUrl: 'https://api.example.com', // Placeholder
                        rateLimit: 1000,
                        assets: ['HOUSING', 'GAS', 'FOOD_INDEX'],
                        lastScrape: null,
                        dataPoints: 0
                    }
                };

                this.scrapedData = JSON.parse(localStorage.getItem('scrapedHistoricalData') || '{}');
                this.initializeUI();
                this.logAction('Historical data scraper initialized', 'success');
            }

            initializeUI() {
                this.updateDataSourcesUI();
            }

            updateDataSourcesUI() {
                const container = document.getElementById('dataSources');
                container.innerHTML = Object.entries(this.dataSources).map(([sourceId, source]) => `
                    <div class="source-card">
                        <div class="source-title">
                            ${source.icon} ${source.name}
                            <span class="status-indicator ${source.status}"></span>
                        </div>
                        <div class="source-description">
                            ${source.description}
                        </div>
                        <div class="source-stats">
                            <div class="source-stat">
                                <strong>${source.assets.length}</strong><br>
                                Assets
                            </div>
                            <div class="source-stat">
                                <strong>${source.dataPoints}</strong><br>
                                Data Points
                            </div>
                        </div>
                        <button class="scrape-btn" onclick="scrapeSource('${sourceId}')" 
                                ${source.status === 'active' ? 'disabled' : ''}>
                            ${source.status === 'active' ? 'Scraping...' : 'Scrape ' + source.name}
                        </button>
                        ${this.getDataPreview(sourceId)}
                    </div>
                `).join('');
            }

            getDataPreview(sourceId) {
                const data = this.scrapedData[sourceId];
                if (!data || Object.keys(data).length === 0) {
                    return '';
                }

                const sampleAsset = Object.keys(data)[0];
                const samplePoints = data[sampleAsset].length;
                const latestPoint = data[sampleAsset][data[sampleAsset].length - 1];

                return `
                    <div class="data-preview">
                        <div class="data-preview-title">Latest Data Sample</div>
                        <div class="data-preview-content">
                            Asset: ${sampleAsset}<br>
                            Points: ${samplePoints}<br>
                            Latest: $${latestPoint ? latestPoint.price.toFixed(2) : 'N/A'}<br>
                            Time: ${latestPoint ? new Date(latestPoint.timestamp).toLocaleString() : 'N/A'}
                        </div>
                    </div>
                `;
            }

            async scrapeSource(sourceId) {
                const source = this.dataSources[sourceId];
                if (source.status === 'active') return;

                source.status = 'active';
                this.updateDataSourcesUI();
                this.logAction(`Starting to scrape ${source.name}...`, 'info');

                try {
                    switch (sourceId) {
                        case 'coingecko':
                            await this.scrapeCoinGecko();
                            break;
                        case 'alphavantage':
                            await this.scrapeAlphaVantage();
                            break;
                        case 'metalspriceapi':
                            await this.scrapeMetalsAPI();
                            break;
                        case 'freeapi':
                            await this.scrapeFreeAPI();
                            break;
                    }
                    
                    source.status = 'idle';
                    source.lastScrape = Date.now();
                    this.logAction(`‚úÖ Successfully scraped ${source.name}`, 'success');
                } catch (error) {
                    source.status = 'error';
                    this.logAction(`‚ùå Error scraping ${source.name}: ${error.message}`, 'error');
                }

                this.updateDataSourcesUI();
                this.saveScrapedData();
            }

            async scrapeCoinGecko() {
                const source = this.dataSources.coingecko;
                const assetMaping = {
                    'bitcoin': 'BTC',
                    'ethereum': 'ETH',
                    'solana': 'SOL',
                    'dogecoin': 'DOGE'
                };

                if (!this.scrapedData.coingecko) {
                    this.scrapedData.coingecko = {};
                }

                for (const asset of source.assets) {
                    try {
                        this.logAction(`Fetching ${asset} data from CoinGecko...`, 'info');
                        
                        // Get 90 days of historical data
                        const url = `${source.baseUrl}/coins/${asset}/market_chart?vs_currency=usd&days=90&interval=daily`;
                        
                        // NOTE: This is a CORS-limited request in browser
                        // In a real implementation, you'd need a backend proxy
                        const response = await this.fetchWithCORS(url);
                        
                        if (response.prices) {
                            const symbol = assetMaping[asset];
                            this.scrapedData.coingecko[symbol] = response.prices.map(([timestamp, price]) => ({
                                timestamp,
                                price
                            }));
                            
                            source.dataPoints += response.prices.length;
                            this.logAction(`‚úÖ Collected ${response.prices.length} data points for ${asset}`, 'success');
                        }
                        
                        // Respect rate limits
                        await this.delay(1200); // 50 requests per minute = 1.2s between requests
                        
                    } catch (error) {
                        this.logAction(`‚ö†Ô∏è Failed to fetch ${asset}: ${error.message}`, 'warning');
                        
                        // Generate fallback simulated data for demo
                        this.generateFallbackData('coingecko', assetMaping[asset], 90);
                    }
                }
            }

            async scrapeAlphaVantage() {
                const source = this.dataSources.alphavantage;
                
                if (!this.scrapedData.alphavantage) {
                    this.scrapedData.alphavantage = {};
                }

                for (const symbol of source.assets) {
                    try {
                        this.logAction(`Fetching ${symbol} data from Alpha Vantage...`, 'info');
                        
                        // Note: Requires API key, this is demo URL
                        const url = `${source.baseUrl}?function=TIME_SERIES_DAILY&symbol=${symbol}&apikey=${source.apiKey}`;
                        
                        // This would fail due to CORS and demo API key
                        // Generate fallback data for demo
                        this.generateFallbackData('alphavantage', symbol, 90);
                        this.logAction(`‚úÖ Generated demo data for ${symbol}`, 'success');
                        
                        await this.delay(12000); // 5 requests per minute = 12s between requests
                        
                    } catch (error) {
                        this.logAction(`‚ö†Ô∏è Failed to fetch ${symbol}: ${error.message}`, 'warning');
                        this.generateFallbackData('alphavantage', symbol, 90);
                    }
                }
            }

            async scrapeMetalsAPI() {
                const source = this.dataSources.metalspriceapi;
                
                if (!this.scrapedData.metalspriceapi) {
                    this.scrapedData.metalspriceapi = {};
                }

                // Generate realistic precious metals data
                for (const metal of source.assets) {
                    this.logAction(`Generating ${metal} historical data...`, 'info');
                    this.generateMetalsData(metal);
                    source.dataPoints += 90;
                    this.logAction(`‚úÖ Generated 90 days of ${metal} data`, 'success');
                }
            }

            async scrapeFreeAPI() {
                const source = this.dataSources.freeapi;
                
                if (!this.scrapedData.freeapi) {
                    this.scrapedData.freeapi = {};
                }

                // Generate consumer goods and real estate data
                const realWorldData = {
                    'HOUSING': { basePrice: 420000, volatility: 0.0005 },
                    'GAS': { basePrice: 3.45, volatility: 0.02 },
                    'FOOD_INDEX': { basePrice: 275.5, volatility: 0.01 }
                };

                for (const [asset, config] of Object.entries(realWorldData)) {
                    this.logAction(`Generating ${asset} historical data...`, 'info');
                    this.generateRealisticData('freeapi', asset, config.basePrice, config.volatility, 90);
                    source.dataPoints += 90;
                    this.logAction(`‚úÖ Generated 90 days of ${asset} data`, 'success');
                }
            }

            generateFallbackData(sourceId, symbol, days) {
                if (!this.scrapedData[sourceId]) {
                    this.scrapedData[sourceId] = {};
                }

                const basePrice = this.getBasePriceForSymbol(symbol);
                const volatility = this.getVolatilityForSymbol(symbol);
                
                this.generateRealisticData(sourceId, symbol, basePrice, volatility, days);
                this.dataSources[sourceId].dataPoints += days;
            }

            generateMetalsData(metal) {
                const metalPrices = {
                    'GOLD': 2050,
                    'SILVER': 24.50,
                    'PLATINUM': 980,
                    'PALLADIUM': 1450
                };

                const basePrice = metalPrices[metal];
                this.generateRealisticData('metalspriceapi', metal, basePrice, 0.002, 90);
            }

            generateRealisticData(sourceId, symbol, basePrice, volatility, days) {
                const data = [];
                let currentPrice = basePrice;
                const now = Date.now();
                
                for (let i = days; i >= 0; i--) {
                    const timestamp = now - (i * 24 * 60 * 60 * 1000);
                    
                    // Add some realistic market movement
                    const randomChange = (Math.random() - 0.5) * 2 * volatility;
                    const trendChange = Math.sin(i / 30) * volatility * 0.5; // 30-day cycle
                    const weekendEffect = this.isWeekend(timestamp) ? volatility * 0.1 : 0;
                    
                    currentPrice = currentPrice * (1 + randomChange + trendChange - weekendEffect);
                    
                    // Ensure price doesn't go negative
                    currentPrice = Math.max(currentPrice, basePrice * 0.1);
                    
                    data.push({
                        timestamp,
                        price: currentPrice
                    });
                }

                this.scrapedData[sourceId][symbol] = data;
            }

            getBasePriceForSymbol(symbol) {
                const prices = {
                    'BTC': 45000,
                    'ETH': 2500,
                    'SOL': 120,
                    'DOGE': 0.08,
                    'SPY': 450,
                    'QQQ': 380,
                    'DIA': 350,
                    'AAPL': 190,
                    'MSFT': 380
                };
                return prices[symbol] || 100;
            }

            getVolatilityForSymbol(symbol) {
                const volatilities = {
                    'BTC': 0.02,
                    'ETH': 0.025,
                    'SOL': 0.03,
                    'DOGE': 0.04,
                    'SPY': 0.01,
                    'QQQ': 0.012,
                    'DIA': 0.008,
                    'AAPL': 0.015,
                    'MSFT': 0.012
                };
                return volatilities[symbol] || 0.01;
            }

            isWeekend(timestamp) {
                const date = new Date(timestamp);
                const dayOfWeek = date.getDay();
                return dayOfWeek === 0 || dayOfWeek === 6; // Sunday or Saturday
            }

            async fetchWithCORS(url) {
                // In a real implementation, this would need a CORS proxy
                // For demo purposes, we'll simulate a failed CORS request
                throw new Error('CORS policy prevents direct API access. Use backend proxy.');
            }

            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            async scrapeAllSources() {
                this.logAction('üöÄ Starting to scrape all data sources...', 'success');
                
                const sourceIds = Object.keys(this.dataSources);
                let completed = 0;
                
                for (const sourceId of sourceIds) {
                    await this.scrapeSource(sourceId);
                    completed++;
                    
                    // Update progress
                    const progress = (completed / sourceIds.length) * 100;
                    document.getElementById('overallProgress').style.width = `${progress}%`;
                    document.getElementById('progressText').textContent = 
                        `Scraped ${completed}/${sourceIds.length} sources (${progress.toFixed(0)}%)`;
                }
                
                this.logAction('üéâ All data sources scraped successfully!', 'success');
            }

            saveScrapedData() {
                try {
                    localStorage.setItem('scrapedHistoricalData', JSON.stringify(this.scrapedData));
                    this.logAction('üìÅ Scraped data saved to local storage', 'success');
                } catch (error) {
                    this.logAction('‚ö†Ô∏è Failed to save scraped data: ' + error.message, 'error');
                }
            }

            exportScrapedData() {
                const totalPoints = Object.values(this.scrapedData).reduce((sum, sourceData) => 
                    sum + Object.values(sourceData).reduce((sourceSum, assetData) => 
                        sourceSum + (assetData ? assetData.length : 0), 0), 0);

                const exportData = {
                    version: '1.0',
                    exportDate: new Date().toISOString(),
                    totalDataPoints: totalPoints,
                    dataSources: Object.keys(this.scrapedData),
                    data: this.scrapedData
                };

                const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `historical-market-data-${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                this.logAction(`üì• Exported ${totalPoints} data points`, 'success');
            }

            clearScrapedData() {
                if (confirm('Are you sure you want to clear all scraped historical data?')) {
                    this.scrapedData = {};
                    localStorage.removeItem('scrapedHistoricalData');
                    
                    // Reset counters
                    Object.values(this.dataSources).forEach(source => {
                        source.dataPoints = 0;
                        source.lastScrape = null;
                    });
                    
                    this.updateDataSourcesUI();
                    this.logAction('üóëÔ∏è All scraped data cleared', 'warning');
                }
            }

            viewDataSummary() {
                const summary = this.generateDataSummary();
                this.logAction('=== DATA SUMMARY ===', 'info');
                this.logAction(`Total Sources: ${summary.totalSources}`, 'info');
                this.logAction(`Total Assets: ${summary.totalAssets}`, 'info');
                this.logAction(`Total Data Points: ${summary.totalDataPoints}`, 'info');
                this.logAction(`Data Coverage: ${summary.dateRange}`, 'info');
                this.logAction(`Storage Size: ${summary.storageSize} KB`, 'info');
                
                Object.entries(summary.sourceBreakdown).forEach(([source, data]) => {
                    this.logAction(`${source}: ${data.assets} assets, ${data.points} points`, 'info');
                });
            }

            generateDataSummary() {
                const totalSources = Object.keys(this.scrapedData).length;
                let totalAssets = 0;
                let totalDataPoints = 0;
                let earliestDate = Date.now();
                let latestDate = 0;
                const sourceBreakdown = {};

                Object.entries(this.scrapedData).forEach(([source, sourceData]) => {
                    const assets = Object.keys(sourceData).length;
                    let points = 0;
                    
                    Object.values(sourceData).forEach(assetData => {
                        if (assetData && assetData.length > 0) {
                            points += assetData.length;
                            earliestDate = Math.min(earliestDate, assetData[0].timestamp);
                            latestDate = Math.max(latestDate, assetData[assetData.length - 1].timestamp);
                        }
                    });
                    
                    totalAssets += assets;
                    totalDataPoints += points;
                    sourceBreakdown[source] = { assets, points };
                });

                const dateRange = totalDataPoints > 0 ? 
                    `${new Date(earliestDate).toLocaleDateString()} - ${new Date(latestDate).toLocaleDateString()}` :
                    'No data';

                const storageSize = (JSON.stringify(this.scrapedData).length / 1024).toFixed(1);

                return {
                    totalSources,
                    totalAssets,
                    totalDataPoints,
                    dateRange,
                    storageSize,
                    sourceBreakdown
                };
            }

            logAction(message, type = 'info') {
                const logContainer = document.getElementById('scrapingLog');
                const entry = document.createElement('div');
                entry.className = `log-entry ${type}`;
                entry.textContent = `${new Date().toLocaleTimeString()}: ${message}`;
                logContainer.appendChild(entry);
                logContainer.scrollTop = logContainer.scrollHeight;
            }
        }

        // Initialize the scraper
        const scraper = new HistoricalDataScraper();

        // Global functions for buttons
        function scrapeSource(sourceId) {
            scraper.scrapeSource(sourceId);
        }

        function scrapeAllSources() {
            scraper.scrapeAllSources();
        }

        function exportScrapedData() {
            scraper.exportScrapedData();
        }

        function clearScrapedData() {
            scraper.clearScrapedData();
        }

        function viewDataSummary() {
            scraper.viewDataSummary();
        }

        // Show initial tip
        setTimeout(() => {
            scraper.logAction('üí° TIP: Due to CORS limitations, this demo generates realistic historical data. In production, use a backend proxy for real API calls.', 'warning');
        }, 2000);
    </script>
</body>
</html>